{{define "title"}}Resource Monitor Â· lumgr{{end}}
{{define "content"}}
<div class="grid" style="gap:16px;">
    <div class="card">
        <h2 style="margin:0 0 8px;">Resource Monitor Configuration</h2>
        <form method="post" action="/admin/resources/config">
            <div class="row">
                <div>
                    <label>Collect interval (seconds)</label>
                    <input type="number" min="1" name="interval_seconds" value="{{.ResmonConfig.IntervalSeconds}}" />
                </div>
                <div>
                    <label>Retention (days)</label>
                    <input type="number" min="1" max="365" name="retention_days"
                        value="{{.ResmonConfig.RetentionDays}}" />
                </div>
            </div>

            <div class="row" style="margin-top:8px;">
                <label><input type="checkbox" name="enabled" value="1" {{if .ResmonConfig.Enabled}}checked{{end}}
                        style="width:auto; margin-right:6px;" />Enabled</label>
                <label><input type="checkbox" name="collect_cpu" value="1" {{if .ResmonConfig.CollectCPU}}checked{{end}}
                        style="width:auto; margin-right:6px;" />CPU</label>
                <label><input type="checkbox" name="collect_memory" value="1" {{if
                        .ResmonConfig.CollectMemory}}checked{{end}}
                        style="width:auto; margin-right:6px;" />Memory</label>
                <label><input type="checkbox" name="collect_disk_io" value="1" {{if
                        .ResmonConfig.CollectDiskIO}}checked{{end}} style="width:auto; margin-right:6px;" />Disk
                    IO</label>
                <label><input type="checkbox" name="collect_filesystem" value="1" {{if
                        .ResmonConfig.CollectFilesystem}}checked{{end}}
                        style="width:auto; margin-right:6px;" />Filesystem</label>
                <label><input type="checkbox" name="collect_network" value="1" {{if
                        .ResmonConfig.CollectNetwork}}checked{{end}}
                        style="width:auto; margin-right:6px;" />Network</label>
                <label><input type="checkbox" name="collect_user_stats" value="1" {{if
                        .ResmonConfig.CollectUserStats}}checked{{end}} style="width:auto; margin-right:6px;" />User
                    stats</label>
            </div>

            <div style="display:flex; justify-content:flex-end; margin-top:12px;">
                <button class="btn primary" type="submit">Save configuration</button>
            </div>
        </form>
    </div>

    <div class="grid two">
        <div class="card">
            <h3 style="margin:0 0 8px;">Current CPU & Memory</h3>
            <div class="muted">CPU usage: <strong><span id="admin-resmon-cpu">{{if .CurrentMetrics}}{{printf "%.1f"
                        .CurrentMetrics.CPUUsage}}{{else}}0.0{{end}}</span>%</strong></div>
            <div class="muted" style="margin-top:4px;">Memory usage: <strong id="admin-resmon-mem-used">{{if
                    .CurrentMetrics}}{{bytes .CurrentMetrics.MemUsed}}{{else}}0 B{{end}}</strong>
                / <span id="admin-resmon-mem-total">{{if .CurrentMetrics}}{{bytes .CurrentMetrics.MemTotal}}{{else}}0
                    B{{end}}</span></div>
        </div>
        <div class="card">
            <h3 style="margin:0 0 8px;">Current Disk & Network</h3>
            <div class="muted">Disk read/write: <strong id="admin-resmon-disk-r">{{if .CurrentMetrics}}{{bytes
                    .CurrentMetrics.DiskReadBytes}}{{else}}0 B{{end}}</strong> /
                <strong id="admin-resmon-disk-w">{{if .CurrentMetrics}}{{bytes .CurrentMetrics.DiskWriteBytes}}{{else}}0
                    B{{end}}</strong>
            </div>
            <div class="muted" style="margin-top:4px;">Network rx/tx: <strong id="admin-resmon-net-rx">{{if
                    .CurrentMetrics}}{{bytes .CurrentMetrics.NetworkRxBytes}}{{else}}0 B{{end}}</strong> /
                <strong id="admin-resmon-net-tx">{{if .CurrentMetrics}}{{bytes .CurrentMetrics.NetworkTxBytes}}{{else}}0
                    B{{end}}</strong>
            </div>
        </div>
    </div>

    <div class="card">
        <h2 style="margin:0 0 8px;">History</h2>
        <form method="get" action="/admin/resources"
            style="display:flex; gap:10px; align-items:flex-end; flex-wrap:wrap; margin-bottom:10px;">
            <div>
                <label>Window (hours)</label>
                <input type="number" name="hours" value="24" min="1" max="720" style="width:120px;" />
            </div>
            <div>
                <label>User filter</label>
                <select name="user" style="min-width:180px;">
                    <option value="">(all users)</option>
                    {{range .ResmonUsers}}
                    <option value="{{.}}" {{if eq $.ResmonSelectedUser .}}selected{{end}}>{{.}}</option>
                    {{end}}
                </select>
            </div>
            <button class="btn" type="submit">Apply</button>
        </form>

        <div style="height:260px; min-height:260px; max-height:260px; position:relative;">
            <canvas id="cpuMemChart"></canvas>
        </div>
        <div style="height:12px"></div>
        <div style="height:260px; min-height:260px; max-height:260px; position:relative;">
            <canvas id="ioChart"></canvas>
        </div>
        <div style="height:12px"></div>
        <div style="height:260px; min-height:260px; max-height:260px; position:relative;">
            <canvas id="userChart"></canvas>
        </div>
    </div>
</div>

<script src="/assets/vendor/chart.min.js"></script>
<script id="resmonSelectedUser" type="application/json">{{toJSON .ResmonSelectedUser}}</script>
<script>
    if (window.__lumgrAdminResmonChartsInit) {
        // prevent duplicate chart/timer setup on accidental duplicate script execution
    } else {
        window.__lumgrAdminResmonChartsInit = true;

        const selectedUser = JSON.parse(document.getElementById('resmonSelectedUser')?.textContent || '""');
        const labels = [];
        const cpuUsage = [];
        const memPct = [];
        const diskRDelta = [];
        const diskWDelta = [];
        const netRxDelta = [];
        const netTxDelta = [];
        let prevCounters = null;
        let timerId = null;

        const formatBytes = (v) => {
            v = Number(v) || 0;
            if (v < 1024) return v + ' B';
            const units = ['KiB', 'MiB', 'GiB', 'TiB', 'PiB'];
            let i = 0;
            while (v >= 1024 && i < units.length - 1) { v /= 1024; i++; }
            return v.toFixed(1) + ' ' + units[i];
        };
        const setText = (id, text) => { const el = document.getElementById(id); if (el) el.textContent = text; };
        const pushWindow = (arr, value) => {
            arr.push(value);
            if (arr.length > 30) arr.shift();
        };

        const cpuMemChart = new Chart(document.getElementById('cpuMemChart'), {
            type: 'line',
            data: {
                labels,
                datasets: [
                    { label: 'CPU %', data: cpuUsage, borderColor: '#7aa2ff', backgroundColor: 'rgba(122,162,255,0.15)' },
                    { label: 'Mem %', data: memPct, borderColor: '#3ddc97', backgroundColor: 'rgba(61,220,151,0.15)' }
                ]
            },
            options: { responsive: true, maintainAspectRatio: false, animation: false }
        });

        const ioChart = new Chart(document.getElementById('ioChart'), {
            type: 'line',
            data: {
                labels,
                datasets: [
                    { label: 'Disk Read Bytes', data: diskRDelta, borderColor: '#f2c879' },
                    { label: 'Disk Write Bytes', data: diskWDelta, borderColor: '#ff8f8f' },
                    { label: 'Net Rx Bytes', data: netRxDelta, borderColor: '#86d6ff' },
                    { label: 'Net Tx Bytes', data: netTxDelta, borderColor: '#c48fff' }
                ]
            },
            options: { responsive: true, maintainAspectRatio: false, animation: false }
        });

        const userChart = new Chart(document.getElementById('userChart'), {
            type: 'bar',
            data: {
                labels: [],
                datasets: [{ label: 'User CPU share %', data: [], backgroundColor: 'rgba(122,162,255,0.4)' }]
            },
            options: { responsive: true, maintainAspectRatio: false, animation: false }
        });

        function renderCurrent(m) {
            setText('admin-resmon-cpu', (Number(m.cpu_usage || 0)).toFixed(1));
            setText('admin-resmon-mem-used', formatBytes(m.mem_used || 0));
            setText('admin-resmon-mem-total', formatBytes(m.mem_total || 0));
            setText('admin-resmon-disk-r', formatBytes(m.disk_read_bytes || 0));
            setText('admin-resmon-disk-w', formatBytes(m.disk_write_bytes || 0));
            setText('admin-resmon-net-rx', formatBytes(m.network_rx_bytes || 0));
            setText('admin-resmon-net-tx', formatBytes(m.network_tx_bytes || 0));
        }

        function rebuildWindow(samples) {
            labels.length = 0;
            cpuUsage.length = 0;
            memPct.length = 0;
            diskRDelta.length = 0;
            diskWDelta.length = 0;
            netRxDelta.length = 0;
            netTxDelta.length = 0;
            prevCounters = null;

            let latestUsers = [];
            for (let i = 0; i < samples.length; i++) {
                const s = samples[i] || {};
                const m = s.metrics || {};
                const d = new Date(s.timestamp || Date.now());
                pushWindow(labels, Number.isNaN(d.getTime()) ? '' : d.toLocaleTimeString());
                pushWindow(cpuUsage, Number(m.cpu_usage || 0));
                const memUsed = Number(m.mem_used || 0);
                const memTotal = Number(m.mem_total || 0);
                pushWindow(memPct, memTotal > 0 ? (memUsed / memTotal) * 100 : 0);

                const curRead = Number(m.disk_read_bytes || 0);
                const curWrite = Number(m.disk_write_bytes || 0);
                const curRx = Number(m.network_rx_bytes || 0);
                const curTx = Number(m.network_tx_bytes || 0);
                let readDelta = 0;
                let writeDelta = 0;
                let rxDelta = 0;
                let txDelta = 0;
                if (prevCounters) {
                    readDelta = Math.max(0, curRead - prevCounters.read);
                    writeDelta = Math.max(0, curWrite - prevCounters.write);
                    rxDelta = Math.max(0, curRx - prevCounters.rx);
                    txDelta = Math.max(0, curTx - prevCounters.tx);
                }
                prevCounters = { read: curRead, write: curWrite, rx: curRx, tx: curTx };
                pushWindow(diskRDelta, readDelta);
                pushWindow(diskWDelta, writeDelta);
                pushWindow(netRxDelta, rxDelta);
                pushWindow(netTxDelta, txDelta);

                if (Array.isArray(s.user_stats)) {
                    latestUsers = s.user_stats;
                }
            }

            const users = selectedUser ? latestUsers.filter((u) => String(u.username || '') === selectedUser) : latestUsers;
            userChart.data.labels = users.map((u) => String(u.username || ''));
            userChart.data.datasets[0].data = users.map((u) => Number(u.cpu_percent || 0));
        }

        async function refreshRealtime() {
            try {
                const res = await fetch('/api/resmon/current', { cache: 'no-store' });
                if (!res.ok) return;
                const payload = await res.json();
                const samples = Array.isArray(payload.realtime_samples) ? payload.realtime_samples.slice(-30) : [];
                if (samples.length === 0) return;
                rebuildWindow(samples);
                const latest = samples[samples.length - 1] || {};
                renderCurrent(latest.metrics || {});
                cpuMemChart.update('none');
                ioChart.update('none');
                userChart.update('none');
            } catch (e) {
                // silent
            }
        }

        refreshRealtime();
        timerId = setInterval(refreshRealtime, 1000);
        window.addEventListener('beforeunload', function () {
            if (timerId) clearInterval(timerId);
            window.__lumgrAdminResmonChartsInit = false;
        });
    }
</script>
{{end}}